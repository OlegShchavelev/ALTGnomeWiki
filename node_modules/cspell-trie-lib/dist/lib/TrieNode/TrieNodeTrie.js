import { consolidate } from '../consolidate.js';
import { findNode } from '../ITrieNode/trie-util.js';
import { mergeOptionalWithDefaults } from '../utils/mergeOptionalWithDefaults.js';
import { findWordExact } from './find.js';
import { trieRootToITrieRoot } from './trie.js';
import { countNodes, createTrieRootFromList, iteratorTrieWords } from './trie-util.js';
export class TrieNodeTrie {
    root;
    _iTrieRoot;
    info;
    _size;
    constructor(root) {
        this.root = root;
        this.info = mergeOptionalWithDefaults(root);
    }
    wordToCharacters = (word) => [...word];
    get iTrieRoot() {
        return this._iTrieRoot || (this._iTrieRoot = trieRootToITrieRoot(this.root));
    }
    getRoot() {
        return this.iTrieRoot;
    }
    getNode(prefix) {
        return findNode(this.getRoot(), prefix);
    }
    words() {
        return iteratorTrieWords(this.root);
    }
    has(word) {
        return findWordExact(this.root, word);
    }
    isForbiddenWord(word) {
        return findWordExact(this.root.c[this.root.forbiddenWordPrefix], word);
    }
    hasForbiddenWords() {
        const root = this.root;
        return !!root.c[root.forbiddenWordPrefix];
    }
    get size() {
        return (this._size ??= countNodes(this.root));
    }
    static createFromWords(words, options) {
        const root = createTrieRootFromList(words, options);
        return new TrieNodeTrie(root);
    }
    static createFromWordsAndConsolidate(words, options) {
        const root = createTrieRootFromList(words, options);
        return new TrieNodeTrie(consolidate(root));
    }
}
//# sourceMappingURL=TrieNodeTrie.js.map